
### Спецификация API

[Cсылка](./reserv-service/API_spec.md)

### Локальный запуск

1. Поднять базу: 
    
    в корне проекта: docker-compose up -d

1. Протестировать и собрать:
    
    ./gradlew build
    
1. Упаковать в докер:

    сd deploy
    
    docker-compose build
    
1. Запустить:

    cd deploy
    
    docker-compose up
    
2. Протестировать в ручную

    [./manual-test/requests.http](./manual-test/requests.http)

 * не проверял ни на какой машине кроме своей.
 Если со сборкой у вас что-то пойдет не так, рассчитываю на понимание.

### Стек

1. Kotlin/Jvm
1. Gradle
1. Spring Boot Web - для HTTP и чтения конфигов
1. Konform - для валидации
1. Flyway - для версионирования БД
1. JDBC + Postgres
1. JUnit - юнит-тесты
1. SpringBootTest + RestAssured - интеграционные тесты
1. Jackson - сериализация
    
    
### Мотивация принятия решений

1. Для возвращения ошибок использую только 409 и 500

    HTTP-статусы не очень информативны и их не много

2. Тестирование

    Для каждого метода API есть интеграционные тесты,
    которые покрывают каждый из предусмотренных сценариев
    
    Интеграционные тесты гоняются с Postgres в силу специфики
    синтаксиса и большей надежности(корректности) таких тестов
    
    Перед каждым блоком тестов чищу базу и накатываю миграции. 
    Не видел чтобы кто-нибудь так делал, то пока кажется неплохой затеей.
    
    Юнит-тестами покрыл только хитрую логику. 
    Отдельно мокать каждый бин не вижу
    большого смысла при наличии интеграционных тестов

3. Транзакции

    Решил отказаться от использования Spring JdbcTemplate, потому, что:
    
    1. непонятно, будет ли это считаться читингом с его поддержкой спринговых транзакций
    1. раз уж мне за эту работу не платят, пусть опыт будет интересным))
    
    Jdbc из коробки не умеет во вложенные транзакции.
    Я сделал обертку (DB) которая обязывает каждую операцию к БД делать в транзакции.
    Если хочется переиспользовать существующую транзакцию, можно передать соответствующий Propagation параметром.
    К сожалению, не успел дописать PropagationSupportedTxManager, то для задачи вроде как хватает и NoPropagationTxManager,
    который на каждый inTransaction{ }-блок создает новую транзакцию
    
4. Логирование

    Знаю, что неплохо бы логами покрыть нормально, но уже вечер воскресенья,
    а завтра по учебе дедлайн.
    
### Фидбек

На задачу потратил порядка 40 часов,
поэтому рассчитываю, по крайней мере, на качественный фидбек с вашей стороны.

Критику воспринимаю легко,
особенно если она сопровождается объективными подтверждениями правоты критикующего
